import type { Express } from "express";
import { createServer, type Server } from "http";
import { storage } from "./storage";
import { insertCarListingSchema, insertBidSchema, insertFavoriteSchema, insertNotificationSchema, insertCarAlertSchema, type CarAlert } from "@shared/schema";
import { z } from "zod";

// Simple in-memory cache
const cache = new Map();
const CACHE_TTL = 1000; // 1 second for faster updates

function getCached(key: string) {
  const cached = cache.get(key);
  if (cached && Date.now() - cached.timestamp < CACHE_TTL) {
    return cached.data;
  }
  return null;
}

function setCache(key: string, data: any) {
  cache.set(key, { data, timestamp: Date.now() });
}

function clearCachePattern(pattern: string) {
  const keys = Array.from(cache.keys());
  keys.forEach(key => {
    if (key.includes(pattern)) {
      cache.delete(key);
    }
  });
}

export async function registerRoutes(app: Express): Promise<Server> {
  // Car listing routes - optimized with caching
  app.get("/api/listings", async (req, res) => {
    try {
      const { status = "active", limit } = req.query;
      const cacheKey = `listings_${status}_${limit || 'all'}`;
      
      // Check cache first
      const cached = getCached(cacheKey);
      if (cached) {
        return res.json(cached);
      }
      
      const listings = await storage.getListingsByStatus(
        status as string, 
        limit ? Number(limit) : undefined
      );
      
      // Optimize: Get all bid counts in single batch query
      const listingIds = listings.map(l => l.id);
      const bidCounts = await storage.getBidCountsForListings(listingIds);
      
      const listingsWithBidCounts = listings.map(listing => ({
        ...listing,
        bidCount: bidCounts[listing.id] || 0
      }));
      
      // Cache the result
      setCache(cacheKey, listingsWithBidCounts);
      
      res.json(listingsWithBidCounts);
    } catch (error) {
      res.status(500).json({ error: "Failed to fetch listings" });
    }
  });

  app.get("/api/listings/search", async (req, res) => {
    try {
      const filters = {
        query: req.query.query as string,
        make: req.query.make as string,
        model: req.query.model as string,
        minPrice: req.query.minPrice ? parseFloat(req.query.minPrice as string) : undefined,
        maxPrice: req.query.maxPrice ? parseFloat(req.query.maxPrice as string) : undefined,
        minYear: req.query.minYear ? parseInt(req.query.minYear as string) : undefined,
        maxYear: req.query.maxYear ? parseInt(req.query.maxYear as string) : undefined
      };
      
      // Create cache key from filters
      const cacheKey = `search_${JSON.stringify(filters)}`;
      
      // Check cache first
      const cached = getCached(cacheKey);
      if (cached) {
        return res.json(cached);
      }
      
      const listings = await storage.searchListings(filters);
      
      // Get bid counts for search results in batch if we have results
      let enrichedListings = listings;
      if (listings.length > 0) {
        const listingIds = listings.map(listing => listing.id);
        const bidCounts = await storage.getBidCountsForListings(listingIds);
        
        enrichedListings = listings.map(listing => ({
          ...listing,
          bidCount: bidCounts[listing.id] || 0
        }));
      }
      
      // Cache the result for 30 seconds
      setCache(cacheKey, enrichedListings);
      
      res.json(enrichedListings);
    } catch (error) {
      res.status(500).json({ error: "Failed to search listings" });
    }
  });

  app.get("/api/listings/:id", async (req, res) => {
    try {
      const listingId = parseInt(req.params.id);
      const listing = await storage.getListing(listingId);
      if (!listing) {
        return res.status(404).json({ error: "Listing not found" });
      }
      res.json(listing);
    } catch (error) {
      res.status(500).json({ error: "Failed to fetch listing" });
    }
  });

  app.post("/api/listings", async (req, res) => {
    try {
      const validatedData = insertCarListingSchema.parse(req.body);
      const listing = await storage.createListing(validatedData);
      
      // Clear listings cache to force refresh
      clearCachePattern('listings_');
      
      // Check for matching car alerts and send notifications
      try {
        console.log('Checking alerts for new listing:', listing.make, listing.model);
        const matchingAlerts = await storage.checkAlertsForNewListing(listing);
        console.log('Found matching alerts:', matchingAlerts.length);
        
        // Group alerts by user to avoid duplicate notifications
        const userAlerts = new Map<number, CarAlert[]>();
        for (const alert of matchingAlerts) {
          if (!userAlerts.has(alert.userId)) {
            userAlerts.set(alert.userId, []);
          }
          userAlerts.get(alert.userId)!.push(alert);
        }
        
        // Send only one notification per user
        for (const [userId, alerts] of Array.from(userAlerts.entries())) {
          console.log('Creating notification for user:', userId, 'matching alerts:', alerts.length);
          await storage.createNotification({
            userId,
            title: "Найден автомобиль по вашему запросу",
            message: `${listing.make} ${listing.model} ${listing.year} г. - ${listing.startingPrice}$ (лот #${listing.lotNumber})`,
            type: "car_found",
            listingId: listing.id,
            isRead: false
          });
        }
      } catch (alertError) {
        console.error('Error checking alerts for new listing:', alertError);
        // Don't fail the listing creation if alert checking fails
      }
      
      res.status(201).json(listing);
    } catch (error) {
      if (error instanceof z.ZodError) {
        return res.status(400).json({ error: "Invalid listing data", details: error.errors });
      }
      res.status(500).json({ error: "Failed to create listing" });
    }
  });

  app.patch("/api/listings/:id/status", async (req, res) => {
    try {
      const listingId = parseInt(req.params.id);
      const { status } = req.body;
      
      if (!["pending", "active", "ended", "rejected"].includes(status)) {
        return res.status(400).json({ error: "Invalid status" });
      }

      const listing = await storage.updateListingStatus(listingId, status);
      if (!listing) {
        return res.status(404).json({ error: "Listing not found" });
      }
      res.json(listing);
    } catch (error) {
      res.status(500).json({ error: "Failed to update listing status" });
    }
  });

  // Bidding routes
  app.get("/api/listings/:id/bids", async (req, res) => {
    try {
      const listingId = parseInt(req.params.id);
      const bids = await storage.getBidsForListing(listingId);
      
      // Enrich bids with user information
      const enrichedBids = await Promise.all(
        bids.map(async (bid) => {
          const user = await storage.getUser(bid.bidderId);
          return {
            ...bid,
            bidder: {
              id: user?.id,
              username: user?.username,
              email: user?.email
            }
          };
        })
      );
      
      res.json(enrichedBids);
    } catch (error) {
      res.status(500).json({ error: "Failed to fetch bids" });
    }
  });

  app.post("/api/listings/:id/bids", async (req, res) => {
    try {
      const listingId = parseInt(req.params.id);
      
      // Check if auction exists and is still active
      const listing = await storage.getListing(listingId);
      if (!listing) {
        return res.status(404).json({ error: "Аукцион не найден" });
      }
      
      // Check if auction has ended
      const now = new Date();
      if (listing.auctionEndTime && listing.auctionEndTime <= now) {
        return res.status(400).json({ error: "Аукцион завершен. Ставки больше не принимаются." });
      }
      
      // Check if auction is active
      if (listing.status !== 'active') {
        return res.status(400).json({ error: "Аукцион неактивен" });
      }
      
      const bidData = {
        ...req.body,
        listingId
      };
      
      const validatedData = insertBidSchema.parse(bidData);
      const bid = await storage.createBid(validatedData);
      
      // Update listing's current bid
      await storage.updateListingCurrentBid(listingId, validatedData.amount);
      if (listing) {
        // Find users who have this listing in favorites
        const usersWithFavorite = await storage.getUsersWithFavoriteListing(listingId);
        
        // Send notifications to users with this listing in favorites (excluding the bidder)
        for (const userId of usersWithFavorite) {
          if (userId !== validatedData.bidderId) {
            await storage.createNotification({
              userId,
              title: "Новая ставка на избранный автомобиль",
              message: `Новая ставка $${validatedData.amount} на ${listing.make} ${listing.model} ${listing.year}`,
              type: "bid_update",
              listingId: listingId,
              isRead: false
            });
          }
        }
      }
      
      res.status(201).json(bid);
    } catch (error) {
      if (error instanceof z.ZodError) {
        return res.status(400).json({ error: "Invalid bid data", details: error.errors });
      }
      res.status(500).json({ error: "Failed to place bid" });
    }
  });

  // User routes
  app.get("/api/users/:id", async (req, res) => {
    try {
      const userId = parseInt(req.params.id);
      const user = await storage.getUser(userId);
      if (!user) {
        return res.status(404).json({ error: "User not found" });
      }
      res.json(user);
    } catch (error) {
      res.status(500).json({ error: "Failed to fetch user" });
    }
  });

  app.get("/api/users/:id/listings", async (req, res) => {
    try {
      const userId = parseInt(req.params.id);
      const listings = await storage.getListingsBySeller(userId);
      res.json(listings);
    } catch (error) {
      res.status(500).json({ error: "Failed to fetch user listings" });
    }
  });

  app.get("/api/users/:id/bids", async (req, res) => {
    try {
      const userId = parseInt(req.params.id);
      const bids = await storage.getBidsByUser(userId);
      res.json(bids);
    } catch (error) {
      res.status(500).json({ error: "Failed to fetch user bids" });
    }
  });

  // Favorites routes
  app.get("/api/users/:id/favorites", async (req, res) => {
    try {
      const userId = parseInt(req.params.id);
      const favorites = await storage.getFavoritesByUser(userId);
      res.json(favorites);
    } catch (error) {
      res.status(500).json({ error: "Failed to fetch favorites" });
    }
  });

  app.post("/api/favorites", async (req, res) => {
    try {
      const validatedData = insertFavoriteSchema.parse(req.body);
      const favorite = await storage.createFavorite(validatedData);
      res.status(201).json(favorite);
    } catch (error) {
      if (error instanceof z.ZodError) {
        return res.status(400).json({ error: "Invalid favorite data", details: error.errors });
      }
      res.status(500).json({ error: "Failed to add favorite" });
    }
  });

  app.delete("/api/favorites/:id", async (req, res) => {
    try {
      const favoriteId = parseInt(req.params.id);
      const success = await storage.deleteFavorite(favoriteId);
      if (!success) {
        return res.status(404).json({ error: "Favorite not found" });
      }
      res.status(204).send();
    } catch (error) {
      res.status(500).json({ error: "Failed to remove favorite" });
    }
  });

  // Search routes
  app.get("/api/search", async (req, res) => {
    try {
      const { q, make, minPrice, maxPrice, year } = req.query;
      const filters = {
        query: q as string,
        make: make as string,
        minPrice: minPrice ? parseFloat(minPrice as string) : undefined,
        maxPrice: maxPrice ? parseFloat(maxPrice as string) : undefined,
        year: year ? parseInt(year as string) : undefined,
      };
      
      const results = await storage.searchListings(filters);
      res.json(results);
    } catch (error) {
      res.status(500).json({ error: "Failed to search listings" });
    }
  });

  // Admin routes
  app.get("/api/admin/stats", async (req, res) => {
    try {
      const stats = await storage.getAdminStats();
      res.json(stats);
    } catch (error) {
      res.status(500).json({ error: "Failed to fetch admin stats" });
    }
  });

  app.get("/api/admin/users", async (req, res) => {
    try {
      const users = await storage.getAllUsers();
      res.json(users);
    } catch (error) {
      res.status(500).json({ error: "Failed to fetch users" });
    }
  });

  app.patch("/api/admin/users/:id/status", async (req, res) => {
    try {
      const userId = parseInt(req.params.id);
      const { isActive } = req.body;
      
      const user = await storage.updateUserStatus(userId, isActive);
      if (!user) {
        return res.status(404).json({ error: "User not found" });
      }
      res.json(user);
    } catch (error) {
      res.status(500).json({ error: "Failed to update user status" });
    }
  });

  // Notifications routes
  app.get("/api/notifications/:userId", async (req, res) => {
    try {
      const userId = parseInt(req.params.userId);
      const notifications = await storage.getNotificationsByUser(userId);
      res.json(notifications);
    } catch (error) {
      res.status(500).json({ error: "Failed to fetch notifications" });
    }
  });

  app.post("/api/notifications", async (req, res) => {
    try {
      const validatedData = insertNotificationSchema.parse(req.body);
      const notification = await storage.createNotification(validatedData);
      res.status(201).json(notification);
    } catch (error) {
      if (error instanceof z.ZodError) {
        return res.status(400).json({ error: "Invalid notification data", details: error.errors });
      }
      res.status(500).json({ error: "Failed to create notification" });
    }
  });

  app.patch("/api/notifications/:id/read", async (req, res) => {
    try {
      const notificationId = parseInt(req.params.id);
      const success = await storage.markNotificationAsRead(notificationId);
      if (!success) {
        return res.status(404).json({ error: "Notification not found" });
      }
      res.status(204).send();
    } catch (error) {
      res.status(500).json({ error: "Failed to mark notification as read" });
    }
  });

  app.delete("/api/notifications/:id", async (req, res) => {
    try {
      const notificationId = parseInt(req.params.id);
      console.log(`Attempting to delete notification with ID: ${notificationId}`);
      
      if (isNaN(notificationId)) {
        console.log(`Invalid notification ID: ${req.params.id}`);
        return res.status(400).json({ error: "Invalid notification ID" });
      }
      
      const success = await storage.deleteNotification(notificationId);
      console.log(`Delete notification result: ${success}`);
      
      if (!success) {
        return res.status(404).json({ error: "Notification not found" });
      }
      res.status(204).send();
    } catch (error) {
      console.error('Error deleting notification:', error);
      res.status(500).json({ error: "Failed to delete notification" });
    }
  });

  app.get("/api/notifications/:userId/unread-count", async (req, res) => {
    try {
      const userId = parseInt(req.params.userId);
      const count = await storage.getUnreadNotificationCount(userId);
      res.json({ count });
    } catch (error) {
      res.status(500).json({ error: "Failed to fetch unread count" });
    }
  });

  // Car alerts routes
  app.get("/api/car-alerts/:userId", async (req, res) => {
    try {
      const userId = parseInt(req.params.userId);
      const alerts = await storage.getCarAlertsByUser(userId);
      res.json(alerts);
    } catch (error) {
      res.status(500).json({ error: "Failed to fetch car alerts" });
    }
  });

  app.get("/api/car-alerts", async (req, res) => {
    try {
      const { userId } = req.query;
      if (!userId) {
        return res.status(400).json({ error: "userId is required" });
      }
      const alerts = await storage.getCarAlertsByUser(parseInt(userId as string));
      res.json(alerts);
    } catch (error) {
      res.status(500).json({ error: "Failed to fetch alerts" });
    }
  });

  app.post("/api/car-alerts", async (req, res) => {
    try {
      const validatedData = insertCarAlertSchema.parse(req.body);
      const alert = await storage.createCarAlert(validatedData);
      res.status(201).json(alert);
    } catch (error) {
      if (error instanceof z.ZodError) {
        return res.status(400).json({ error: "Invalid alert data", details: error.errors });
      }
      res.status(500).json({ error: "Failed to create alert" });
    }
  });

  app.delete("/api/car-alerts/:id", async (req, res) => {
    try {
      const alertId = parseInt(req.params.id);
      const success = await storage.deleteCarAlert(alertId);
      if (!success) {
        return res.status(404).json({ error: "Alert not found" });
      }
      res.status(204).send();
    } catch (error) {
      res.status(500).json({ error: "Failed to delete alert" });
    }
  });

  const httpServer = createServer(app);
  return httpServer;
}
